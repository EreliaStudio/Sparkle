#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <unordered_map>
#include <iomanip>
#include <filesystem>  // Requires C++17 or later

int main(int argc, char** argv)
{
    // We expect at least 4 arguments:
    //   1) outputHeader.hpp
    //   2) baseDirectory
    //   3+) resource files...
    if (argc < 4) {
        std::cerr << "Usage: " << argv[0] 
                  << " <outputHeader.hpp> <baseDirectory> <file1> [file2] ...\n";
        return 1;
    }

    const std::string outputHeader = argv[1];
    const std::string baseDirectory = argv[2];

    // Gather resource files
    std::vector<std::string> inputFiles;
    for (int i = 3; i < argc; ++i) {
        inputFiles.push_back(argv[i]);
    }

    // Open the output .hpp
    std::ofstream out(outputHeader);
    if (!out.is_open()) {
        std::cerr << "Error: could not open output file: " << outputHeader << "\n";
        return 1;
    }

    // Write the header prologue
    out << "#pragma once\n";
    out << "#include <string>\n";
    out << "#include <vector>\n";
    out << "#include <unordered_map>\n\n";
    out << "// Auto-generated by sparkleResourcesConverter\n";
    out << "// Contains embedded data for the following files:\n";
    for (auto &f : inputFiles) {
        out << "//   " << f << "\n";
    }
    out << "\n";

    out << "static const std::unordered_map<std::string, std::vector<unsigned char>> sparkle_resources = {\n";

    // For each file, read in binary and embed it
    for (size_t idx = 0; idx < inputFiles.size(); ++idx) {
		const auto& keyName = inputFiles[idx];
        const auto& filePath = baseDirectory + "/" + keyName;

        // Open the file in binary mode
        std::ifstream in(filePath, std::ios::binary | std::ios::ate);
        if (!in) {
            std::cerr << "Error: cannot open " << filePath << "\n";
            return 1;
        }

        std::streamsize fileSize = in.tellg();
        in.seekg(0, std::ios::beg);
        std::vector<unsigned char> buffer(fileSize);

        if (!in.read(reinterpret_cast<char*>(buffer.data()), fileSize)) {
            std::cerr << "Error: failed to read " << filePath << "\n";
            return 1;
        }
        in.close();

        // This relPath.string() is what we'll store as the key.
        out << "    { \"" << keyName << "\", {\n        ";

        // Dump the file data as hex, 16 bytes per line
        for (size_t i = 0; i < buffer.size(); ++i) {
            out << "0x" << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(buffer[i]) << ", ";
            if ((i + 1) % 16 == 0) {
                out << "\n        ";
            }
        }
        out << "\n    } }";
        if (idx + 1 < inputFiles.size()) {
            out << ",";
        }
        out << "\n";
    }

    out << "};\n\n";
    out << "#define SPARKLE_GET_RESOURCE(key) sparkle_resources.at(key)\n";
	out << "#define SPARKLE_GET_RESOURCE_AS_STRING(key) std::wstring(sparkle_resources.at(key).begin(), sparkle_resources.at(key).end())\n";

    out.close();
    return 0;
}
