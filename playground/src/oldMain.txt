#include <algorithm>
#include <array>
#include <cmath>
#include <iostream>
#include <list>
#include <memory>
#include <numbers>
#include <sparkle.hpp>
#include <unordered_map>
#include <vector>



namespace playground
{
	class Shape : public spk::Entity
	{
	public:
		enum class Type
		{
			Triangle,
			Square,
			Pentagon,
			Hexagon,
			Octagon,
			Circle
		};

		class Renderer : public spk::Component
		{
		private:
			struct Instance
			{
				spk::Matrix4x4 model;
				spk::Color color;
			};

			struct Data
			{
				using InstanceList = std::list<Instance>;
				using InstanceIterator = InstanceList::iterator;

				spk::ColorMesh colorMesh;
				spk::CollisionMesh2D collisionMesh;
				InstanceList instances;
				spk::SafePointer<spk::ColorMeshRenderer> renderer;

				Data() = default;

				Data(size_t p_pointCount, spk::Entity *p_owner, const std::wstring &p_rendererName)
				{
					std::vector<spk::Vector2> vertices = Renderer::_generateVertices(p_pointCount);

					std::vector<spk::ColorVertex> colorVertices;
					std::vector<spk::ColorVertex2D> colorVertices2D;
					for (const auto &pos : vertices)
					{
						colorVertices.push_back({{pos.x, pos.y, 0.0f}, spk::Color::white});
						colorVertices2D.push_back({pos, spk::Color::white});
					}
					colorMesh.addShape(colorVertices);

					spk::ColorMesh2D tmpMesh;
					tmpMesh.addShape(colorVertices2D);
					collisionMesh = spk::CollisionMesh2D::fromMesh(&tmpMesh);

					renderer = p_owner->addComponent<spk::ColorMeshRenderer>(p_rendererName);
					if (renderer != nullptr)
					{
						renderer->setMesh(&colorMesh);
					}
				}

				InstanceIterator addInstance(spk::SafePointer<spk::Transform> p_transform, const spk::Color &p_color)
				{
					return instances.emplace(instances.end(), Instance{p_transform->model(), p_color});
				}

				void updateInstance(InstanceIterator p_iterator, const spk::Matrix4x4 &p_model)
				{
					if (p_iterator != instances.end())
					{
						p_iterator->model = p_model;
					}
				}

				void removeInstance(InstanceIterator p_iterator)
				{
					if (p_iterator != instances.end())
					{
						instances.erase(p_iterator);
					}
				}

				void clearInstances()
				{
					instances.clear();
				}
			};

			inline static Renderer *_instance = nullptr;

			std::unordered_map<Type, Data> _data;

			inline static const std::unordered_map<Type, size_t> _pointCounts = {
				{Type::Triangle, 3}, {Type::Square, 4}, {Type::Pentagon, 5}, {Type::Hexagon, 6}, {Type::Octagon, 8}, {Type::Circle, 32}};

			static std::vector<spk::Vector2> _generateVertices(size_t p_pointCount)
			{
				std::vector<spk::Vector2> vertices;
				vertices.reserve(p_pointCount);
				if (p_pointCount == 4)
				{
					float h = 0.5f;
					vertices.push_back({-h, -h});
					vertices.push_back({h, -h});
					vertices.push_back({h, h});
					vertices.push_back({-h, h});
					return vertices;
				}

				float step = 2.0f * std::numbers::pi_v<float> / static_cast<float>(p_pointCount);
				for (size_t i = 0; i < p_pointCount; ++i)
				{
					float angle = step * static_cast<float>(i);
					float x = std::cos(angle) * 0.5f;
					float y = std::sin(angle) * 0.5f;
					vertices.push_back({x, y});
				}
				return vertices;
			}

		public:
			Renderer(const std::wstring &p_name) :
				spk::Component(p_name)
			{
			}

			void start() override
			{
				_instance = this;
				_data.emplace(Type::Triangle, Data(_pointCounts.at(Type::Triangle), owner(), name() + L"/RendererTriangle"));
				_data.emplace(Type::Square, Data(_pointCounts.at(Type::Square), owner(), name() + L"/RendererSquare"));
				_data.emplace(Type::Pentagon, Data(_pointCounts.at(Type::Pentagon), owner(), name() + L"/RendererPentagon"));
				_data.emplace(Type::Hexagon, Data(_pointCounts.at(Type::Hexagon), owner(), name() + L"/RendererHexagon"));
				_data.emplace(Type::Octagon, Data(_pointCounts.at(Type::Octagon), owner(), name() + L"/RendererOctagon"));
				_data.emplace(Type::Circle, Data(_pointCounts.at(Type::Circle), owner(), name() + L"/RendererCircle"));
			}

			void stop() override
			{
				for (auto &pair : _data)
				{
					auto &renderer = pair.second.renderer;
					if (renderer != nullptr)
					{
						owner()->removeComponent(renderer->name());
					}
					pair.second.clearInstances();
					renderer = nullptr;
				}
				_instance = nullptr;
			}

			void onPaintEvent(spk::PaintEvent& p_event) override
			{

			}

			using InstanceIterator = Data::InstanceIterator;

			InstanceIterator addInstance(Type p_type, spk::SafePointer<spk::Transform> p_transform, const spk::Color &p_color)
			{
				return _data[p_type].addInstance(p_transform, p_color);
			}

			void updateInstance(Type p_type, InstanceIterator p_iterator, const spk::Matrix4x4 &p_model)
			{
				auto it = _data.find(p_type);
				if (it != _data.end())
				{
					it->second.updateInstance(p_iterator, p_model);
				}
			}

			void removeInstance(Type p_type, InstanceIterator p_iterator)
			{
				auto it = _data.find(p_type);
				if (it != _data.end())
				{
					it->second.removeInstance(p_iterator);
				}
			}

			bool isIteratorValid(Type p_type, InstanceIterator p_iterator) const
			{
				auto it = _data.find(p_type);
				if (it == _data.end())
				{
					return false;
				}
				return p_iterator != it->second.instances.end();
			}

			static spk::SafePointer<Renderer> instance()
			{
				return spk::SafePointer<Renderer>(_instance);
			}

			static const spk::ColorMesh &getColorMesh(Type p_type)
			{
				return _instance->_data.at(p_type).colorMesh;
			}

			static const spk::CollisionMesh2D &getCollisionMesh(Type p_type)
			{
				return _instance->_data.at(p_type).collisionMesh;
			}
		};

		class Subscriber : public spk::Component
		{
		private:
			Type _type;
			spk::Color _color;
			Renderer::InstanceIterator _iterator;
			spk::ContractProvider::Contract _transformContract;

		public:
			Subscriber(const std::wstring &p_name, Type p_type, const spk::Color &p_color) :
				spk::Component(p_name),
				_type(p_type),
				_color(p_color)
			{
			}

			void start() override
			{
				_transformContract = owner()->transform().addOnEditionCallback(
					[this]()
					{
						auto renderer = Renderer::instance();
						if (renderer != nullptr && renderer->isIteratorValid(_type, _iterator) == true)
						{
							renderer->updateInstance(_type, _iterator, owner()->transform().model());
						}
					});
			}

			void awake() override
			{
				auto renderer = Renderer::instance();
				if (renderer != nullptr)
				{
					spk::SafePointer<spk::Transform> transform(&owner()->transform());
					_iterator = renderer->addInstance(_type, transform, _color);
				}
			}

			void sleep() override
			{
				auto renderer = Renderer::instance();
				if (renderer != nullptr && renderer->isIteratorValid(_type, _iterator) == true)
				{
					renderer->removeInstance(_type, _iterator);
					_iterator = Renderer::InstanceIterator();
				}
			}
		};

		class Collision : public spk::Component
		{
		private:
			Type _type;
			spk::SafePointer<spk::Collider2D> _internalCollider;

		public:
			Collision(const std::wstring &p_name, Type p_type) :
				spk::Component(p_name),
				_type(p_type)
			{
			}

			void start() override
			{
				_internalCollider = owner()->addComponent<spk::Collider2D>(name() + L"/Collider2D");
				if (_internalCollider != nullptr)
				{
					_internalCollider->setCollisionMesh(&Renderer::getCollisionMesh(_type));
				}
			}

			void stop() override
			{
				if (_internalCollider != nullptr)
				{
					owner()->removeComponent(_internalCollider->name());
				}
				_internalCollider = nullptr;
			}
		};

		Shape(const std::wstring &p_name, Type p_type, const spk::Color &p_color, spk::SafePointer<spk::Entity> p_parent = nullptr) :
			spk::Entity(p_name, p_parent)
		{
			addComponent<Subscriber>(p_name + L"/ShapeSubscriber", p_type, p_color);
			addComponent<Collision>(p_name + L"/ShapeCollision", p_type);
		}
	};
}

enum class TileFlag
{
	None,
	Obstacle,
	TerritoryBlue,
	TerritoryGreen,
	TerritoryRed
};

class PlaygroundTileMap : public spk::TileMap<16, 16, 4, TileFlag>
{
private:
	void _onChunkGeneration(const spk::Vector2Int &p_chunkCoordinate, Chunk &p_chunkToFill) override
	{
		for (int i = 0; i < Chunk::size.x; i++)
		{
			for (int j = 0; j < Chunk::size.y; j++)
			{
				if (i == 0 || j == 0)
				{
					p_chunkToFill.setContent(i, j, 0, 0);
				}
				else
				{
					p_chunkToFill.setContent(i, j, 0, (rand() % 3) + 1);
				}
			}
		}

		auto collisionManager = p_chunkToFill.addComponent<Chunk::Collider>(p_chunkToFill.name() + L"/Collider");
		collisionManager->setFlag(TileFlag::Obstacle);
	}

public:
	using spk::TileMap<16, 16, 4, TileFlag>::TileMap;

	PlaygroundTileMap(const std::wstring &p_name, spk::SafePointer<spk::Entity> p_parent) :
		spk::TileMap<16, 16, 4, TileFlag>(p_name, p_parent)
	{
	}
};

class TileMapChunkStreamer : public spk::Component
{
private:
	spk::SafePointer<PlaygroundTileMap> _tileMap;
	spk::SafePointer<spk::CameraComponent> _cameraComponent;
	spk::ContractProvider::Contract _transformContract;
	spk::Vector2Int _lastChunk = spk::Vector2Int(0, 0);
	bool _hasLastChunk = false;

	spk::Vector2Int _computeChunk(const spk::Vector3 &p_worldPos) const
	{
		const spk::Vector2Int &size = PlaygroundTileMap::Chunk::size;
		int cx = static_cast<int>(std::floor(p_worldPos.x / static_cast<float>(size.x)));
		int cy = static_cast<int>(std::floor(p_worldPos.y / static_cast<float>(size.y)));
		return spk::Vector2Int(cx, cy);
	}

	void _refreshRange()
	{
		if (_tileMap == nullptr)
		{
			return;
		}

		spk::SafePointer<spk::Entity> ownerEntity = owner();
		if (ownerEntity == nullptr)
		{
			return;
		}

		spk::Vector2Int start;
		spk::Vector2Int end;

		if (_cameraComponent != nullptr)
		{
			const spk::Camera &cam = _cameraComponent->camera();
			const spk::Matrix4x4 &camModel = _cameraComponent->owner()->transform().model();

			auto toWorld = [&](const spk::Vector2 &p_ndc) -> spk::Vector3
			{
				spk::Vector3 inCam = cam.convertScreenToCamera(p_ndc);
				return (camModel * spk::Vector4(inCam, 1.0f)).xyz();
			};

			spk::Vector3 wBL = toWorld(spk::Vector2(-1.0f, -1.0f));
			spk::Vector3 wBR = toWorld(spk::Vector2(1.0f, -1.0f));
			spk::Vector3 wTL = toWorld(spk::Vector2(-1.0f, 1.0f));
			spk::Vector3 wTR = toWorld(spk::Vector2(1.0f, 1.0f));

			float minX = std::min(std::min(wBL.x, wBR.x), std::min(wTL.x, wTR.x));
			float maxX = std::max(std::max(wBL.x, wBR.x), std::max(wTL.x, wTR.x));
			float minY = std::min(std::min(wBL.y, wBR.y), std::min(wTL.y, wTR.y));
			float maxY = std::max(std::max(wBL.y, wBR.y), std::max(wTL.y, wTR.y));

			const spk::Vector2Int &cs = PlaygroundTileMap::Chunk::size;
			start.x = static_cast<int>(std::floor(minX / static_cast<float>(cs.x))) - 1;
			start.y = static_cast<int>(std::floor(minY / static_cast<float>(cs.y))) - 1;
			end.x = static_cast<int>(std::floor(maxX / static_cast<float>(cs.x))) + 1;
			end.y = static_cast<int>(std::floor(maxY / static_cast<float>(cs.y))) + 1;
		}

		spk::Vector2Int curr = _computeChunk(ownerEntity->transform().position());
		if ((_hasLastChunk == true) && (curr == _lastChunk))
		{
			return;
		}

		_lastChunk = curr;
		_hasLastChunk = true;
		_tileMap->setChunkRange(start, end);
	}

public:
	TileMapChunkStreamer(
		const std::wstring &p_name, spk::SafePointer<PlaygroundTileMap> p_tileMap, spk::SafePointer<spk::CameraComponent> p_cameraComponent) :
		spk::Component(p_name),
		_tileMap(p_tileMap),
		_cameraComponent(p_cameraComponent)
	{
	}

	void awake() override
	{
		if (owner() != nullptr)
		{
			_transformContract = owner()->transform().addOnEditionCallback([&]() { _refreshRange(); });
		}

		_refreshRange();
	}

	void sleep() override
	{
		if (_transformContract.isValid())
		{
			_transformContract.resign();
		}
	}
};

class TopDown2DController : public spk::Component
{
public:
	struct Configuration
	{
		static inline const std::wstring ForwardActionName = L"Forward";
		static inline const std::wstring LeftActionName = L"Left";
		static inline const std::wstring BackwardActionName = L"Backward";
		static inline const std::wstring RightActionName = L"Right";

		float moveSpeed = 5.0f;
		std::unordered_map<std::wstring, spk::Keyboard::Key> keymap = {
			{ForwardActionName, spk::Keyboard::Z},
			{LeftActionName, spk::Keyboard::Q},
			{BackwardActionName, spk::Keyboard::S},
			{RightActionName, spk::Keyboard::D}};
	};

private:
	Configuration _config;
	std::vector<std::unique_ptr<spk::Action>> _actions;
	spk::Vector3 _motionRequested = {0, 0, 0};

	void _applyConfiguration()
	{
		dynamic_cast<spk::KeyboardAction *>(_actions[0].get())->setDeviceValue(_config.keymap[L"Forward"], spk::InputState::Down);
		dynamic_cast<spk::KeyboardAction *>(_actions[1].get())->setDeviceValue(_config.keymap[L"Left"], spk::InputState::Down);
		dynamic_cast<spk::KeyboardAction *>(_actions[2].get())->setDeviceValue(_config.keymap[L"Backward"], spk::InputState::Down);
		dynamic_cast<spk::KeyboardAction *>(_actions[3].get())->setDeviceValue(_config.keymap[L"Right"], spk::InputState::Down);
	}

public:
	TopDown2DController(const std::wstring &p_name) :
		spk::Component(p_name)
	{
		_actions.push_back(
			std::make_unique<spk::KeyboardAction>(
				_config.keymap[L"Forward"],
				spk::InputState::Down,
				10,
				[&](const spk::SafePointer<const spk::Keyboard> &p_keyboard) { _motionRequested += spk::Vector3(0, 1, 0); }));

		_actions.push_back(
			std::make_unique<spk::KeyboardAction>(
				_config.keymap[L"Left"],
				spk::InputState::Down,
				10,
				[&](const spk::SafePointer<const spk::Keyboard> &p_keyboard) { _motionRequested -= spk::Vector3(1, 0, 0); }));

		_actions.push_back(
			std::make_unique<spk::KeyboardAction>(
				_config.keymap[L"Backward"],
				spk::InputState::Down,
				10,
				[&](const spk::SafePointer<const spk::Keyboard> &p_keyboard) { _motionRequested -= spk::Vector3(0, 1, 0); }));

		_actions.push_back(
			std::make_unique<spk::KeyboardAction>(
				_config.keymap[L"Right"],
				spk::InputState::Down,
				10,
				[&](const spk::SafePointer<const spk::Keyboard> &p_keyboard) { _motionRequested += spk::Vector3(1, 0, 0); }));
	}

	void setConfiguration(const Configuration &p_configuration)
	{
		_config = p_configuration;
		_applyConfiguration();
	}

	const Configuration &configuration() const
	{
		return (_config);
	}

	void onUpdateEvent(spk::UpdateEvent &p_event) override
	{
		if ((p_event.keyboard == nullptr) == true)
		{
			return;
		}

		_motionRequested = spk::Vector3(0, 0, 0);

		for (auto &action : _actions)
		{
			if ((action->isInitialized() == false) == true)
			{
				action->initialize(p_event);
			}

			action->update();
		}

		bool isMotionRequested = (_motionRequested != spk::Vector3());
		if (isMotionRequested == true)
		{
			spk::Vector3 delta = _motionRequested.normalize() * (float)p_event.deltaTime.seconds * _config.moveSpeed;
			owner()->transform().move(delta);
			p_event.requestPaint();
		}
	}
};

class DebugOverlayManager : public spk::Widget
{
private:
	spk::Profiler::Instanciator _profilerInstanciator;
	spk::DebugOverlay _debugOverlay;

	void _updateOutlineFromLayout()
	{
		const uint32_t labelHeight = _debugOverlay.labelHeight();
		const uint32_t outlineSize = std::max<uint32_t>(1u, labelHeight / 6u);
		_debugOverlay.setFontOutlineSize(outlineSize);
	}

	void _onGeometryChange() override
	{
		spk::Vector2UInt s = geometry().size;
		s.y = std::min(s.y, _debugOverlay.computeMaxHeightPixels());
		_debugOverlay.setGeometry({{0, 0}, s});
		_updateOutlineFromLayout();
	}

	void _onUpdateEvent(spk::UpdateEvent &p_event) override
	{
		size_t fps = 0;
		double fpsMs = 0.0;
		double fpsMinMs = 0.0;
		double fpsMaxMs = 0.0;
		size_t fpsMin = 0;
		size_t fpsMax = 0;

		size_t ups = 0;
		double upsMs = 0.0;
		double upsMinMs = 0.0;
		double upsMaxMs = 0.0;
		size_t upsMin = 0;
		size_t upsMax = 0;

		if (p_event.window != nullptr)
		{
			spk::SafePointer<spk::Window> wnd = p_event.window;
			if (wnd != nullptr)
			{
				fps = wnd->FPS();
				fpsMs = wnd->realFPSDuration();
				fpsMinMs = wnd->minFPSDuration();
				fpsMaxMs = wnd->maxFPSDuration();
				fpsMin = wnd->minFPS();
				fpsMax = wnd->maxFPS();

				ups = wnd->UPS();
				upsMs = wnd->realUPSDuration();
				upsMinMs = wnd->minUPSDuration();
				upsMaxMs = wnd->maxUPSDuration();
				upsMin = wnd->minUPS();
				upsMax = wnd->maxUPS();
			}
		}

		_debugOverlay.setText(0, 0, L"FPS Counter : " + std::to_wstring(fps));
		_debugOverlay.setText(1, 0, L"FPS Duration : " + std::to_wstring(fpsMs) + L" ms");
		_debugOverlay.setText(2, 0, L"Min duration : " + std::to_wstring(fpsMinMs) + L" ms");
		_debugOverlay.setText(3, 0, L"Max duration : " + std::to_wstring(fpsMaxMs) + L" ms");
		_debugOverlay.setText(4, 0, L"Min FPS : " + std::to_wstring(fpsMin));
		_debugOverlay.setText(5, 0, L"Max FPS : " + std::to_wstring(fpsMax));
		_debugOverlay.setText(6, 0, L"");
		_debugOverlay.setText(7, 0, L"UPS Counter : " + std::to_wstring(ups));
		_debugOverlay.setText(8, 0, L"UPS Duration : " + std::to_wstring(upsMs) + L" ms");
		_debugOverlay.setText(9, 0, L"Min duration : " + std::to_wstring(upsMinMs) + L" ms");
		_debugOverlay.setText(10, 0, L"Max duration : " + std::to_wstring(upsMaxMs) + L" ms");
		_debugOverlay.setText(11, 0, L"Min UPS : " + std::to_wstring(upsMin));
		_debugOverlay.setText(12, 0, L"Max UPS : " + std::to_wstring(upsMax));

		p_event.requestPaint();
	}

public:
	DebugOverlayManager(const std::wstring &p_name, spk::SafePointer<spk::Widget> p_parent) :
		spk::Widget(p_name, p_parent),
		_debugOverlay(p_name + L"/Overlay", this)
	{
		_debugOverlay.setMaxGlyphSize(30);
		_debugOverlay.setFontOutlineSize(4);
		_debugOverlay.setFontOutlineSharpness(1);
		_debugOverlay.setFontColor(spk::Color::white, spk::Color::black);

		_debugOverlay.configureRows(20, 1);
		_debugOverlay.activate();
	}
};

int main()
{
	spk::GraphicalApplication app;
	auto window = app.createWindow(L"Playground", {{0, 0}, {800, 600}});
	window->setUpdateTimer(0);

	DebugOverlayManager debugOverlay(L"DebugOverlay", window->widget());
	debugOverlay.setGeometry({0, 0}, window->geometry().size);
	debugOverlay.setLayer(100);
	debugOverlay.activate();

	spk::GameEngine engine;
	spk::GameEngineWidget engineWidget(L"EngineWidget", window->widget());
	engineWidget.setGeometry({{0, 0}, window->geometry().size});
	engineWidget.setGameEngine(&engine);
	engineWidget.activate();

	spk::Entity player(L"Player", nullptr);
	player.transform().place({4, 4, 2.5f});
	player.addComponent<TopDown2DController>(L"Player/TopDown2DController");

	spk::SpriteSheet playerSpriteSheet("playground/resources/texture/player_sprite_sheet.png", {4, 4});
	spk::Mesh2D playerMesh = spk::Primitive2D::makeSquare({1.0f, 1.0f}, playerSpriteSheet.sprite({0, 0}));
	spk::CollisionMesh2D playerCollisionMesh = spk::CollisionMesh2D::fromMesh(&playerMesh);
	auto playerRenderer = player.addComponent<spk::Mesh2DRenderer>(L"Player/Mesh2DRenderer");
	playerRenderer->setTexture(&playerSpriteSheet);
	playerRenderer->setMesh(&playerMesh);
	auto playerCollider = player.addComponent<spk::Collider2D>(L"Player/Collider2D");
	playerCollider->setCollisionMesh(&playerCollisionMesh);

	spk::Entity cameraHolder(L"Camera", &player);
	auto cameraComponent = cameraHolder.addComponent<spk::CameraComponent>(L"Camera/CameraComponent");
	cameraHolder.transform().place({0.0f, 0.0f, 20.0f});
	cameraHolder.transform().lookAt(player.transform().position());

	try
	{
		cameraComponent->setOrthographic(64.0f, 64.0f);
	} catch (const std::exception &e)
	{
		PROPAGATE_ERROR("Error while computing the camera as orthographic", e);
	}

	PlaygroundTileMap tileMap(L"TileMap", nullptr);
	spk::SpriteSheet tilemapSpriteSheet("playground/resources/texture/tile_map.png", {16, 6});
	tileMap.activate();
	engine.addEntity(&tileMap);
	tileMap.setSpriteSheet(&tilemapSpriteSheet);

	tileMap.addTileByID(0, PlaygroundTileMap::TileType({0, 0}, PlaygroundTileMap::TileType::Type::Autotile, TileFlag::Obstacle)); // Wall
	tileMap.addTileByID(
		1, PlaygroundTileMap::TileType({4, 0}, PlaygroundTileMap::TileType::Type::Autotile, TileFlag::TerritoryBlue)); // Blue territory
	tileMap.addTileByID(
		2, PlaygroundTileMap::TileType({8, 0}, PlaygroundTileMap::TileType::Type::Autotile, TileFlag::TerritoryGreen)); // Green territory
	tileMap.addTileByID(
		3, PlaygroundTileMap::TileType({12, 0}, PlaygroundTileMap::TileType::Type::Autotile, TileFlag::TerritoryRed)); // Red territory

	player.addComponent<TileMapChunkStreamer>(L"Player/TileMapChunkStreamer", &tileMap, cameraComponent);

	spk::SafePointer<spk::Entity> playerPtr(&player);
	for (const auto &collider : spk::Collider2D::getColliders())
	{
		if (collider.get() == playerCollider.get())
		{
			continue;
		}
		collider->onCollisionEnter(
			[playerPtr](spk::SafePointer<spk::Entity> p_entity)
			{
				if (p_entity.get() == playerPtr.get())
				{
					std::wcout << L"Player entered chunk collision mesh" << std::endl;
				}
			});
	}

	player.activate();
	cameraHolder.activate();
	engine.addEntity(&player);

	spk::Entity shapesRoot(L"Shapes", nullptr);
	shapesRoot.addComponent<playground::Shape::Renderer>(L"Shapes/ShapeRenderer");
	engine.addEntity(&shapesRoot);
	shapesRoot.activate();

	std::vector<std::unique_ptr<playground::Shape>> shapes;
	auto createShapes = [&](playground::Shape::Type p_type,
							const std::array<spk::Color, 3> &p_colors,
							const std::array<spk::Vector3, 3> &p_positions,
							const std::wstring &p_base)
	{
		for (size_t i = 0; i < 3; ++i)
		{
			auto shape = std::make_unique<playground::Shape>(p_base + std::to_wstring(i), p_type, p_colors[i], &shapesRoot);
			shape->transform().place(p_positions[i]);
			shape->activate();
			shapes.push_back(std::move(shape));
		}
	};

	std::array<spk::Color, 3> colors = {spk::Color::red, spk::Color::green, spk::Color::blue};
	createShapes(
		playground::Shape::Type::Triangle,
		colors,
		{spk::Vector3(-9.0f, -9.0f, 0.0f), spk::Vector3(0.0f, -9.0f, 0.0f), spk::Vector3(9.0f, -9.0f, 0.0f)},
		L"Triangle");
	createShapes(
		playground::Shape::Type::Square,
		colors,
		{spk::Vector3(-9.0f, -5.0f, 0.0f), spk::Vector3(0.0f, -5.0f, 0.0f), spk::Vector3(9.0f, -5.0f, 0.0f)},
		L"Square");
	createShapes(
		playground::Shape::Type::Pentagon,
		colors,
		{spk::Vector3(-9.0f, -1.0f, 0.0f), spk::Vector3(0.0f, -1.0f, 0.0f), spk::Vector3(9.0f, -1.0f, 0.0f)},
		L"Pentagon");
	createShapes(
		playground::Shape::Type::Hexagon,
		colors,
		{spk::Vector3(-9.0f, 3.0f, 0.0f), spk::Vector3(0.0f, 3.0f, 0.0f), spk::Vector3(9.0f, 3.0f, 0.0f)},
		L"Hexagon");
	createShapes(
		playground::Shape::Type::Octagon,
		colors,
		{spk::Vector3(-9.0f, 7.0f, 0.0f), spk::Vector3(0.0f, 7.0f, 0.0f), spk::Vector3(9.0f, 7.0f, 0.0f)},
		L"Octagon");
	createShapes(
		playground::Shape::Type::Circle,
		colors,
		{spk::Vector3(-9.0f, 9.0f, 0.0f), spk::Vector3(0.0f, 9.0f, 0.0f), spk::Vector3(9.0f, 9.0f, 0.0f)},
		L"Circle");

	return app.run();
}
